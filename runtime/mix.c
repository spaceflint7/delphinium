
// ------------------------------------------------------------
//
// js_unary_op
//
// ------------------------------------------------------------

js_val js_unary_op (js_environ *env, int op, js_val val) {

    if (op == '+') // does not support BigInt
        return js_tonumber(env, val);

    if (op != '-' && op != '~')
        js_callthrow("TypeError_unsupported_operation");

    if (js_is_object(val))
        val = js_obj_to_primitive_number(env, val);

    if (js_is_primitive_bigint(val))
        return js_big_unary_negate(env, val, (op == '-'));

    if (!js_is_number(val))
        val = js_tonumber(env, val);

    return js_make_number(op == '-' ? -val.num
                                    : ~(int32_t)val.num);
}

// ------------------------------------------------------------
//
// js_binary_op
//
// ------------------------------------------------------------

js_val js_binary_op (js_environ *env, int op,
                     js_val left, js_val right) {

    if (op == '+') {

        left  = js_obj_to_primitive_default(env, left);
        right = js_obj_to_primitive_default(env, right);

        if (js_is_primitive_string(left)
        ||  js_is_primitive_string(right)) {

            return js_str_concat(env, left, right);
        }

    } else {

        if (js_is_object(left))
            left = js_obj_to_primitive_number(env, left);

        if (js_is_object(right))
            right = js_obj_to_primitive_number(env, right);
    }

    if (!js_is_primitive_bigint(left))
        left = js_tonumber(env, left);

    if (!js_is_primitive_bigint(right))
        right = js_tonumber(env, right);

    if (js_is_primitive_bigint(left)) {
        if (js_is_primitive_bigint(right))
            return js_big_binary_op(env, op, left, right);

    } else if (js_is_number(left)) {
        if (js_is_number(right))
            return js_num_binary_op(env, op, left, right);
    }

    // while this is a catch-all, we should only get here
    // if one parameter is bigint and the other is number
    js_callthrow("TypeError_mix_types_in_arithmetic");
    return js_undefined;
}

// ------------------------------------------------------------
//
// js_strict_eq
//
// ------------------------------------------------------------

bool js_strict_eq (js_environ *env,
                   js_val left, js_val right) {

    //
    // for strict equality, both values must be of the same
    // type.  we check for primitive types first, because
    // that would be the typical case when we reach here.
    // most cases should be handled by the inline C code
    // generated by strict_equality () in compare_writer.js
    //

    if (js_is_primitive(left)) {

        if (!js_is_primitive(right))
            return false;

        int prim_type = js_get_primitive_type(left);
        if (prim_type != js_get_primitive_type(right))
            return false;

        if (prim_type == js_prim_is_string)
            return js_str_equals(env, left, right);

        if (prim_type == js_prim_is_bigint)
            return js_big_compare(left, right) == 0;

    } else if (js_is_number(left)) {

        if (!js_is_number(right))
            return false;

        // if either is NaN returns false,
        // otherwise x == y, where -0 == +0
        return left.num == right.num;

    } else if (js_is_undefined(left))
        return js_is_undefined(right);

    // symbol, boolean, object reach here
    return left.raw == right.raw;
}

// ------------------------------------------------------------
//
// js_loose_eq
//
// ------------------------------------------------------------

bool js_loose_eq (js_environ *env,
                  js_val left, js_val right) {

    //
    // test #1, the two values null and undefined are
    // treated as equal, and not equal to anything else
    //

    if (js_is_undefined_or_null(left))
        return js_is_undefined_or_null(right);

    else if (js_is_undefined_or_null(right))
        return false;

    //
    // test #2, if left or right is an object, then other
    // side either matches on reference, or otherwise gets
    // converted to a primitive value, to keep comparing
    //

    if (js_is_object(left)) {

        if (left.raw == right.raw) {
            // right is the same object, return true
            return true;
        }

        if (js_is_number(right) || js_is_primitive(right))
            left = js_obj_to_primitive_default(env, left);

        else {
            // in loose equality, when one side is an object,
            // other side must be string/bigint/symbol/number
            return false;
        }

    } else if (js_is_object(right)) {

        if (js_is_number(left) || js_is_primitive(left))
            right = js_obj_to_primitive_default(env, right);
        else
            return false;
    }

    //
    // test #3, if both sides are the same boolean,
    // otherwise convert boolean values to 0.0 or 1.0
    // for the numeric comparison further down
    //

    if (js_is_boolean(left)) {

        if (left.raw == right.raw) {
            // right is the same boolean value, return true
            return true;
        }

        left.num = (double)(left.raw & 1);
    }

    if (js_is_boolean(right))
        right.num = (double)(right.raw & 1);

    //
    // test #4, if both sides are strings, then compare
    // the strings by value;  if only one side is a string,
    // and the other is a number or a bigint, then convert
    // the string to a number or a bigint
    //

    if (js_is_primitive_string(left)) {

        if (js_is_primitive_string(right)) {

            // compare strings by value
            // (or by reference if interned strings)
            return js_str_equals(env, left, right);
        }

        if (js_is_number(right)) {
            // convert string to number for comparison
            left = js_tonumber(env, left);

        } else if (js_is_primitive_bigint(right)) {
            // convert string to bigint for comparison
            left = js_big_from_str(env, left);

        } else
            return false;

    } else if (js_is_primitive_string(right)) {

        if (js_is_number(left)) {
            // convert string to number for comparison
            right = js_tonumber(env, right);

        } else if (js_is_primitive_bigint(left)) {
            // convert string to bigint for comparison
            right = js_big_from_str(env, right);

        } else
            return false;
    }

    //
    // test #5, if either is bigint, then compare both
    // as bigints;  convert from a number, if necessary
    //

    if (js_is_primitive_bigint(left)) {

        if (js_is_number(right))
            right = js_big_from_num(env, right);

        if (js_is_primitive_bigint(right))
            return js_big_compare(left, right) == 0;

    } else if (js_is_primitive_bigint(right)) {

        if (js_is_number(left))
            left = js_big_from_num(env, left);

        if (js_is_primitive_bigint(left))
            return js_big_compare(left, right) == 0;

    } else if (js_is_number(left) && js_is_number(right)) {

        // if either is NaN returns false,
        // otherwise x == y, where -0 == +0
        return left.num == right.num;
    }

    // catch-all, but we should only get here when either
    // side is a symbol;  or if js_big_parse () conversion
    // failed and produced js_undefined;  or if either side
    // is a bigint, and the other is a non-finite number.
    // in all these cases, the following comparison is ok.

    return (left.raw == right.raw);
}

// ------------------------------------------------------------
//
// js_less_than
//
// ------------------------------------------------------------

bool js_less_than (js_environ *env, int flags,
                   js_val left, js_val right) {

    // convert objects to primitive values, making sure
    // to respect the requested order of evaluation,
    // see also compare_relational () in compare_writer.js

    if (flags & 1) {

        //
        // bit 0 set - evaluate left operand before right
        //

        if (js_is_object(left))
            left = js_obj_to_primitive_number(env, left);

        if (js_is_object(right))
            right = js_obj_to_primitive_number(env, right);

    } else {

        //
        // bit 0 clear - evaluate right operand before left
        //

        if (js_is_object(right))
            right = js_obj_to_primitive_number(env, right);

        if (js_is_object(left))
            left = js_obj_to_primitive_number(env, left);
    }

    //
    // compare three kinds of input types:
    // string;  bigint;  and number-convertible,
    // which is anything else (e.g. boolean),
    // converted to a number.
    //

    bool nan = false;
    bool cmp;

    if (js_is_primitive_string(left)) {

        //
        // left is a string
        //

        if (js_is_primitive_string(right)) {

            //
            // string vs. string.
            // compare lexicographiclly.
            //

            cmp = (js_str_compare(left, right) < 0);

        } else if (js_is_primitive_bigint(right)) {

            //
            // string vs. bigint.  compare as bigints.
            // conversion fails silently, and treated
            // same as NaN.
            //

            left = js_big_from_str(env, left);
            if (js_is_undefined(left))
                nan = true;
            else
                cmp = (js_big_compare(left, right) < 0);

        } else {

            //
            // string vs. number-convertible.
            // compare as doubles, except if NaN.
            //

            left = js_tonumber(env, left);
            right = js_tonumber(env, right);

            if (left.raw == js_nan.raw
            || right.raw == js_nan.raw)
                nan = true;
            else
                cmp = (left.num < right.num);
        }

    } else if (js_is_primitive_bigint(left)) {

        //
        // left is a bigint
        //

        if (js_is_primitive_string(right)) {

            //
            // bigint vs. string.  compare as bigints.
            // conversion fails silently, and treated
            // same as NaN.
            //

            right = js_big_from_str(env, right);
            if (js_is_undefined(right))
                nan = true;
            else
                cmp = (js_big_compare(left, right) < 0);

        } else if (js_is_primitive_bigint(right)) {

            //
            // bigint vs. bigint.  compare as bigints.
            //

            cmp = (js_big_compare(left, right) < 0);

        } else {

            //
            // bigint vs. number-convertible.
            // compare as bigints except if NaN.
            //

            right = js_tonumber(env, right);
            if (right.raw == js_nan.raw)
                nan = true;
            else
                cmp = (js_big_compare_num(
                        env, left, right.num) < 0);
        }

    } else {

        //
        // left is number-convertible.
        //

        left = js_tonumber(env, left);
        if (left.raw == js_nan.raw)
            nan = true;

        else if (js_is_primitive_bigint(right)) {

            //
            // number-convertible vs. bigint.
            // note the inversion of the comparison.
            //

            cmp = (js_big_compare_num(
                        env, right, left.num) > 0);

        } else {

            //
            // number-convertible vs.
            //          string or number-convertible.
            // compare as doubles, except if NaN.
            //

            right = js_tonumber(env, right);
            if (right.raw == js_nan.raw)
                nan = true;
            else
                cmp = (left.num < right.num);
        }
    }

    //
    // inversion of result - determined by bit 4, and used
    // in less-than-or-equal or greater-than-or-equal,
    // see also compare_relational () in compare_writer.js.
    // when bit 4 is set, the result should be inverted,
    // unless one of the operands was detected as NaN.
    //

    if (nan)
        cmp = false;            // always false if NaN
    else if (flags & 0x10)
        cmp = !cmp;
    return cmp;
}

// ------------------------------------------------------------
//
// js_check_truthy
//
// ------------------------------------------------------------

bool js_check_truthy (js_val val) {

    if (js_is_primitive(val)) {

        switch (js_get_primitive_type(val)) {

            case js_prim_is_string:
                // for a string type, non-empty string is truthy
                return (((const objset_id *)
                                js_get_pointer(val))->len != 0);

            case js_prim_is_symbol:
                return true;

            case js_prim_is_bigint:
                // for a bigint type, non-zero is truthy
                return js_big_check_truthy(val);
        }

    } else if (js_is_object(val)) {

        // any object reference is always truthy
        return true;

    } else if (js_is_number(val)) {

        // for a number type, a non-NaN non-zero is truthy
        const double num = js_get_number(val);
        if (num == num && num != 0.0)
            return true;

    } else if (val.raw == js_true.raw) {

        // for a boolean type, only true is truthy
        return true;
    }

    // any other value is falsy
    return false;
}

// ------------------------------------------------------------
//
// typeof
//
// ------------------------------------------------------------

js_val js_typeof (js_environ *env, js_val val) {

    if (js_is_number(val))
        return env->str_number;

    if (js_is_primitive(val)) {

        switch (js_get_primitive_type(val)) {

            case js_prim_is_string:
                return env->str_string;

            case js_prim_is_symbol:
                return env->str_symbol;

            case js_prim_is_bigint:
                return env->str_bigint;
        }
    }

    if (js_is_object(val)) {

        const js_obj *obj_ptr = (js_obj *)js_get_pointer(val);
        if (js_obj_is_exotic(obj_ptr, js_obj_is_function))
            return env->str_function;
        else
            return env->str_object;
    }

    if (val.raw == js_null.raw)
        return env->str_object;

    if (js_is_boolean(val))
        return env->str_boolean;

    return env->str_undefined;
}

// ------------------------------------------------------------
//
// js_boxthis
//
// ------------------------------------------------------------

js_val js_boxthis (js_environ *env, js_val this_val) {

    if (js_is_object(this_val))
        return this_val;

    if (js_is_undefined_or_null(this_val)) {
        // make sure to return non-flagged global object,
        // see also js_obj_init () and js_obj_init_2 ()
        return js_make_object(
                        js_get_pointer(env->global_obj));
    }

    if (!env->obj_constructor.raw) {

        int64_t dummy_shape_cache;
        env->obj_constructor = js_getprop(
            env, env->shadow_obj, js_str_c(env, "Object"),
            &dummy_shape_cache);
    }

    return js_callfunc1(env, env->obj_constructor,
                        js_undefined, this_val);
}
