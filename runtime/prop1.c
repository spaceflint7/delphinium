
// ------------------------------------------------------------
//
// forward declarations
//
// ------------------------------------------------------------

static js_val js_getprop_proxy (
                js_environ *env, js_val obj, js_val prop);

static bool js_delprop_proxy (
                js_environ *env, js_val obj, js_val prop);

static int js_hasprop_proxy (
                js_environ *env, js_val obj, js_val prop);

// ------------------------------------------------------------
//
// js_getprop
//
// ------------------------------------------------------------

js_val js_getprop (js_environ *env, js_val obj, js_val prop,
                   int64_t *shape_cache) {

    //printf("js_getprop ");js_print(env, prop);printf("\n");

    // clear the shape cache which records the shape id and
    // array index where the value is found.
    int64_t dummy_shape_cache;
    *shape_cache = 0;

    // first thing we do is identify the object that we need
    // to scan:  the input object, if it is really an object.
    // or if primitive, this is the corresponding prototype.

    js_obj *obj_ptr;
    if (likely(js_is_object(obj)))
        obj_ptr = js_get_pointer(obj);

    else {

        if (likely(js_is_primitive_string(obj))) {

            // this is a string primitive, check if property
            // is valid on the string, i.e. it is 'length'
            // or an integer index between 0 and length

            js_val str_val = js_str_getprop(env, obj, prop);

            if (str_val.raw != js_deleted.raw)
                return str_val;

            // otherwise we need to scan String.prototype
            obj_ptr = env->str_proto;

        } else {

            if (js_is_undefined_or_null(obj)) {
                // throw if get property of undefined or null
                js_callshadow(env,
                    "TypeError_get_property_of_null_object",
                    prop);
            }

            // get the appropriate prototype object to scan
            obj_ptr = js_get_primitive_proto(env, obj);
        }

        // disable cache because there is no initial object
        shape_cache = &dummy_shape_cache;
    }

    //
    // main loop for getprop
    //

    uint32_t prop_idx = 0;
    int64_t prop_key = 0;

    for (;;) {

        uintptr_t proto = (uintptr_t)obj_ptr->proto;
        js_val get_val = js_deleted;
        int64_t idx_or_ptr = 0;

        if ((proto & 7) == js_obj_is_array) {

            if (!prop_idx) {
                prop_idx = js_str_is_length_or_number(
                                env, prop);
            }

            if (prop_idx < js_len_index) {
                // returns js_deleted if no such element,
                // so we continue on the prototype chain.
                // this should be the case with any 'hole'
                // index in the array, whether below or
                // beyond the actual length of the array
                get_val = js_arr_get(obj, prop_idx);
            }

        } else if ((proto & 7) == js_obj_is_proxy) {

            get_val = js_getprop_proxy(env, obj, prop);
        }

        if (get_val.raw == js_deleted.raw) {

            if (!prop_key)
                prop_key = js_shape_key(env, prop);

            if (js_shape_value(
                    obj_ptr->shape, prop_key, &idx_or_ptr)
                                            && idx_or_ptr < 0) {

                get_val = obj_ptr->values[~idx_or_ptr];
            }
        }

        // if the value was not found, continue on the
        // prototype, until we hit the end of the chain.

        if (get_val.raw == js_deleted.raw) {

            // if we reached the end of the prototype chain,
            // then the property was not found
            proto &= ~7;
            if (!proto) {

                if (obj.raw == env->global_obj.raw) {
                    // in strict mode, unqualified access
                    // should throw ReferenceError for
                    // undeclared vars.  see also
                    // js_obj_init () and js_obj_init_2 ()
                    js_throw_if_strict_1(
                        "ReferenceError_not_defined", prop);
                }

                // otherwise just a normal value not found
                return js_undefined;
            }

            obj_ptr = (js_obj *)proto;

            // disable cache as we move off the initial object
            shape_cache = &dummy_shape_cache;
            continue;
        }

        // if the value is found directly on the object,
        // we can cache the shape id and array index,
        // and code generated by functions like
        // member_expression () can use that to bypass
        // this function.  see also expression_writer.js
        // and calculation_writer.js

        if (!js_is_descriptor(get_val)) {

            if (idx_or_ptr < 0) {
                // update shape cache for direct value
                js_shape_update_cache_key(
                        shape_cache, obj_ptr, ~idx_or_ptr);
            }

            return get_val;
        }

        //
        // the property is actually a descriptor.  for a
        // data descriptor, we can still cache the access.
        //

        const js_descriptor *descr =
                            js_get_pointer(get_val);
        int flags = js_descr_flags_without_setter(descr);

        if (flags & js_descr_value) {

            // update shape cache for data descriptor
            if (idx_or_ptr < 0) {
                js_shape_update_cache_key_descr(
                            shape_cache, obj_ptr,
                            (~idx_or_ptr), flags);
            }
            // return value of data descriptor
            return descr->data_or_getter;
        }

        // if this is an accessor, call getter
        if (flags & js_descr_getter) {

            return js_callfunc1(env, descr->data_or_getter,
                                obj, js_undefined);
        }

        // otherwise must be a setter-only descriptor
        return js_undefined;
    }
}

// ------------------------------------------------------------
//
// js_getprop_proxy
//
// ------------------------------------------------------------

static js_val js_getprop_proxy (
                js_environ *env, js_val obj, js_val prop) {

    printf("PROXY NOT IMPL YET\n");
    return js_deleted;
}

// ------------------------------------------------------------
//
// js_delprop
//
// ------------------------------------------------------------

js_val js_delprop (
            js_environ *env, js_val obj, js_val prop) {

    // deleting properties on a primitive value throws
    // an error in strict mode, otherwise returns false.
    // if the property does not exist, return true.

    if (!js_is_object(obj)) {

        if (likely(js_is_primitive_string(obj))) {

            // this is a string primitive, check if property
            // is valid on the string, i.e. it is 'length' or
            // an integer index between 0 and length.  if so,
            // we throw error in strict mode, else ignore.

            if (js_str_setprop(env, obj, prop))
                return js_false;
        }

        if (js_is_undefined_or_null(obj)) {
            // cannot delete properties of undefined or null
            js_callthrow("TypeError_convert_null_to_object");
        }

        // other than string, no other primitives have 'own'
        // properties to delete, so we can just return true
        return js_true;
    }

    //
    // delete an 'own' property on an object, which may
    // be an array or a proxy, otherwise a plain object
    //

    js_obj *obj_ptr = js_get_pointer(obj);
    uintptr_t proto = (uintptr_t)obj_ptr->proto;

    if ((proto & 7) == js_obj_is_array) {

        // delete an integer index on an array object:
        // disallowed only if the array index exists
        // and is a non-configurable descriptor.

        uint32_t prop_idx =
                js_str_is_length_or_number(env, prop);

        if (prop_idx < js_len_index) {

            js_val old_val = js_arr_get(obj, prop_idx);

            if (old_val.raw == js_deleted.raw) {
                // delete non-existent element is ok
                return js_true;
            }

            if (!js_is_descriptor(old_val)) {
                // delete a plain, non-descriptor element
                js_arr_set(env, obj, prop_idx, js_deleted);
                return js_true;
            }

            // configurable descriptor must be freed
            // in addition to marking the array element

            js_descriptor *descr =
                                js_get_pointer(old_val);
            const int flags =
                    js_descr_flags_without_setter(descr);

            if (flags & js_descr_config) {
                // ok to delete non-configurable element
                js_arr_set(env, obj, prop_idx, js_deleted);
                js_gc_free(env, descr);
                return js_true;
            }

            // cannot delete a non-configurable property
            js_throw_if_strict_1(
                        "TypeError_deleteProperty", prop);
            return js_false;
        }

    } else if ((proto & 7) == js_obj_is_proxy) {

        // proxy deletion.  if proxy implements the delete
        // trap, and the delete trap returns false, then
        // we stop.  otherwise, we still have to keep going
        // to make sure the property is configurable.

        if (!js_delprop_proxy(env, obj, prop))
            return js_false;
    }

    //
    // look for the property on a plain object.  we also
    // reach here for a 'length' property on an array,
    // which is ok because length is not configurable.
    //

    const int64_t prop_key = js_shape_key(env, prop);
    int64_t idx_or_ptr;

    if (js_shape_value(
            obj_ptr->shape, prop_key, &idx_or_ptr)
                                    && idx_or_ptr < 0) {

        js_val old_val = obj_ptr->values[~idx_or_ptr];

        // invalidate any shape cached for this object,
        // see js_defineProperty_object () in descr2.c
        obj_ptr->shape_id = ++env->next_unique_id;

        if (old_val.raw != js_deleted.raw) {

            if (!js_is_descriptor(old_val)) {
                // delete a plain, non-descriptor element
                obj_ptr->values[~idx_or_ptr] = js_deleted;
                return js_true;
            }

            // configurable descriptor must be freed
            // in addition to marking the array element

            js_descriptor *descr =
                                js_get_pointer(old_val);
            const int flags =
                    js_descr_flags_without_setter(descr);

            if (flags & js_descr_config) {
                // ok to delete non-configurable element
                obj_ptr->values[~idx_or_ptr] = js_deleted;
                js_gc_free(env, descr);
                return js_true;
            }

            // cannot delete a non-configurable property
            js_throw_if_strict_1(
                        "TypeError_deleteProperty", prop);
            return js_false;
        }
    }

    // property was not found on the object, ok to delete
    return js_true;
}

// ------------------------------------------------------------
//
// js_delprop_proxy
//
// ------------------------------------------------------------

static bool js_delprop_proxy (
                js_environ *env, js_val obj, js_val prop) {

    printf("PROXY NOT IMPL YET\n");
    return true;
}

// ------------------------------------------------------------
//
// js_hasprop
//
// ------------------------------------------------------------

bool js_hasprop (js_environ *env, js_val obj, js_val prop) {

    // binary operator 'in' throws an error on non-objects
    js_throw_if_notobj(env, obj);
    js_obj *obj_ptr = js_get_pointer(obj);

    //
    // main loop for hasprop
    //

    uint32_t prop_idx = 0;
    int64_t prop_key = 0;

    for (;;) {

        uintptr_t proto = (uintptr_t)obj_ptr->proto;
        js_val get_val = js_deleted;

        if ((proto & 7) == js_obj_is_array) {

            if (!prop_idx) {
                prop_idx = js_str_is_length_or_number(
                                env, prop);
            }

            if (prop_idx < js_len_index) {
                // returns js_deleted if no such element,
                // so we continue on the prototype chain.
                // this should be the case with any 'hole'
                // index in the array, whether below or
                // beyond the actual length of the array
                get_val = js_arr_get(obj, prop_idx);
            }

        } else if ((proto & 7) == js_obj_is_proxy) {

            int proxy_has = js_hasprop_proxy(env, obj, prop);
            if (proxy_has != -1)
                return proxy_has;
        }

        if (get_val.raw == js_deleted.raw) {

            if (!prop_key)
                prop_key = js_shape_key(env, prop);

            int64_t idx_or_ptr;
            if (js_shape_value(
                    obj_ptr->shape, prop_key, &idx_or_ptr)
                                            && idx_or_ptr < 0) {

                get_val = obj_ptr->values[~idx_or_ptr];
            }
        }

        // if the value was not found, continue on the
        // prototype, until we hit the end of the chain.

        if (get_val.raw != js_deleted.raw)
            return true;

        if (!proto)
            return false;

        obj_ptr = (js_obj *)(proto & ~7);
    }
}

// ------------------------------------------------------------
//
// js_hasprop_proxy
//
// ------------------------------------------------------------

static int js_hasprop_proxy (
                js_environ *env, js_val obj, js_val prop) {

    printf("PROXY NOT IMPL YET\n");
    return -1;
}
